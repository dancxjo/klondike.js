<!doctype html>
<html>
	<head>
		<meta charset="UTF-8">
		<link rel="stylesheet" type="text/css" href="cards.css" media="screen" />
    <script src="cards.js"></script>
    <style>
    	.pile {
    		width: 5em;    		
    		float: left;
    	}
    </style>
	</head>
	<body>
		<div>
			<div id="top">
				<ul id="foundation1"></ul>
				<ul id="foundation2"></ul>
				<ul id="foundation3"></ul>
				<ul id="foundation4"></ul>
				<ul id="playingArea"></ul>
				<ul id="deck">					
				</ul>
			</div>
			
			<div id="piles">			
				<ul id="pile1"></ul>
				<ul id="pile2"></ul>
				<ul id="pile3"></ul>
				<ul id="pile4"></ul>
				<ul id="pile5"></ul>
				<ul id="pile6"></ul>
				<ul id="pile7"></ul>
			</div>
		</div>
				
		<script>
			var draggingCard = null;			
			
			function handleClick(ev, card) {				
				console.log(card);				
				if (!card.up) {
					var parent = card.el.parentElement.parentElement;				
					if (parent.className == "pile") {
						if (parent.stack.top() == card) {
							card.flip();
						}
					} else if (parent.className == "deck") {
						if (parent.stack.top() == card) {
							card.flip();
							deck.pop();
							playingArea.push(card);
						}
					}
				}								
			}									
			
			function handleDrag(ev) {								
				var card = ev.target.card;
				var playable = true;
				if (card.up && playable) {										
					// Make a new 
					ev.dataTransfer.setData("text", JSON.stringify({rank:card.rank, suit:card.suit}));				
					draggingCard = ev.target.card;
				}
			}									
			
			function canPileDrop(ev, card) {
				if (card.up) {
					var parent = card.el.parentElement.parentElement;				
					if (parent.className == "pile") {
						if (parent.stack.top() == card) {
							if (draggingCard.getColor() != card.getColor() && draggingCard.rank + 1 == card.rank) {
								card.el.style.outline = "5px solid yellow";
								ev.preventDefault();
								return false;
							}
						}
					} 
				}
			}
			
			function pileDrop(ev, card) {
				ev.preventDefault();				
				card.el.style.outline = "none";
				var oldParent = draggingCard.el.parentElement.parentElement;
				var reachedDragger = false;
				for (var i = 0; i < oldParent.children.length; i++) {
					if (oldParent.children[i] == draggingCard.el.parentElement) {
						reachedDragger = true;
					}
					if (reachedDragger) {
						var cardToMove = oldParent.children[i].children[0].card;
						oldParent.removeChild(oldParent.children[i]);
						card.el.parentElement.parentElement.stack.push(cardToMove);
						i--;
					}
				}
				// Remove the card from its current parent					
				//draggingCard.el.parentElement.parentElement.removeChild(draggingCard.el.parentElement);
				//card.el.parentElement.parentElement.stack.push(draggingCard);				
			}						
			
			var deck = new Deck(document.getElementById("deck"));
			for (var i = 0; i < deck.el.children.length; i++) {
				var li = deck.el.children[i];			
				var cardel = li.children[0];
				cardel.ondragstart = handleDrag;				
				cardel.onclick = function (card) { return function(ev) { return handleClick(ev, card); }}(cardel.card);
				cardel.ondragover = function (card) { return function(ev) { return canPileDrop(ev, card);}}(cardel.card);
				cardel.ondragleave = function (card) { return function (ev) {
					card.el.style.outline = "none";
				}}(cardel.card);
				cardel.ondrop = function (card) { return function(ev) { return pileDrop(ev, card);}}(cardel.card);
			}
			
			deck.el.onclick = function (ev) {
				if (deck.getLength() == 0) {
					// Move any playing area cards back to deck
					while (playingArea.getLength() > 0) {
						var card = playingArea.pop();
						card.flip();
						deck.push(card);
					}
				}
			}
			
			var foundations = [
				new Foundation(document.getElementById("foundation1")),
				new Foundation(document.getElementById("foundation2")),
				new Foundation(document.getElementById("foundation3")),
				new Foundation(document.getElementById("foundation4"))
			];
			
			for (var i = 0; i < foundations.length; i++) {
				var f = foundations[i];
				f.el.ondragover = function (ev) {					
					//var card = JSON.parse(ev.dataTransfer.getData("text"));
					var card = draggingCard;
										
					if (this.children.length == 0) {						
						// Require an ace
						if (card.rank == Ace) {
							this.style.outline = "5px solid yellow";
							ev.preventDefault();
							return false;
						}
					} else {
						var top = this.stack.top();
						if (card.rank - 1 == top.rank && card.suit == top.suit) {
							this.style.outline = "5px solid yellow";
							ev.preventDefault();
							return false;
						}
					}
				}
				
				f.el.ondragleave = function (ev) {
					this.style.outline = "none";
				}
				
				f.el.ondrop = function (ev) {
					ev.preventDefault();
					var card = draggingCard;
					this.style.outline = "none";
					// Remove the card from its current parent					
					card.el.parentElement.parentElement.removeChild(card.el.parentElement);
					this.stack.push(card);					
				}
			}
			
			var playingArea = new PlayingArea(document.getElementById("playingArea"));
			
			var piles = [
				new Pile(document.getElementById("pile1")),
				new Pile(document.getElementById("pile2")),
				new Pile(document.getElementById("pile3")),
				new Pile(document.getElementById("pile4")),
				new Pile(document.getElementById("pile5")),
				new Pile(document.getElementById("pile6")),
				new Pile(document.getElementById("pile7")),
			];
			
			for (var a = 0; a < 7; a++) {
				for (var b = a; b < 7; b++) {
					var card = deck.pop();
					piles[b].push(card);
					if (a == b) {
						card.flip();
					}
				}
			}									
			/*
			function draw() {
				// Clear current playable Card
				if (playingArea.getLength() > 0) {							
					playingArea.top().el.onclick = null;
				}
				
				var card = deck.pop();
				card.flip();				
				playingArea.push(card);
				// TODO: Make playingArea top playable				
				card.el.onclick = null;
				
				if (deck.getLength() > 0) {
					deck.top().el.onclick = function () {
						draw();
					}
				} else {
					// Move any playing area cards back to deck
					while (playingArea.getLength() > 0) {
						var card = playingArea.pop();
						card.flip();
						deck.push(card);
					}
					if (deck.getLength() > 0) {
						draw();
					}
				}
			}
			
			
			draw();
			*/
		</script>
	</body>
</html>
